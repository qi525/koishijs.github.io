(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{387:function(a,t,s){"use strict";s.r(t);var v=s(25),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"概率机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概率机制"}},[a._v("#")]),a._v(" 概率机制")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),s("p",[a._v("本页中默认机器人的昵称为“四季酱”。")])]),a._v(" "),s("h2",{attrs:{id:"基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[a._v("#")]),a._v(" 基本用法")]),a._v(" "),s("p",[a._v("我们有时也希望某些回答按照特定的概率进行触发。这个时候我们可以使用 "),s("code",[a._v("-p prob")]),a._v(" 的语法进行设置。例如 "),s("code",[a._v("# 问题 回答 -p 0.2")]),a._v(" 设置的问题的触发概率即为 20%。")]),a._v(" "),s("p",[a._v("那么如果一个问题存在多个回答，每个回答的触发概率又是如何计算的呢？Koishi 会求出所有问答的触发概率之和，因此得到两种处理方式：")]),a._v(" "),s("ul",[s("li",[a._v("如果总和不大于 1，则按照各自的概率触发各个问题")]),a._v(" "),s("li",[a._v("如果总和大于 1，则各个问答的概率将被除以这个总和后以各自的概率触发这个问题")])]),a._v(" "),s("p",[a._v("举个例子。如果一个问题有两个回答，概率分别为 0.3 和 0.5，则实际操作中这两个回答的触发概率就是 0.3 和 0.5。但是如果一个问题有两个回答，概率分别是 0.6 和 1，因为总概率超过 1，因此两个问答的触发概率将被标准化，实际操作中它们的触发概率分别为 0.375 和 0.625 以保证总概率正好为 1。")]),a._v(" "),s("h2",{attrs:{id:"称呼匹配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#称呼匹配"}},[a._v("#")]),a._v(" 称呼匹配")]),a._v(" "),s("p",[a._v("Koishi 的指令可以通过 @bot 或使用昵称进行调用。同理，教学系统中也有一套类似的机制用于匹配含有称呼的指令。")]),a._v(" "),s("p",[a._v("我们认为，每一个问题都拥有两个概率，一个是"),s("strong",[a._v("严格匹配")]),a._v("（说是严格实际上包含了上文所介绍的 "),s("a",{attrs:{href:"#%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D"}},[s("strong",[a._v("模糊匹配")])]),a._v(" 机制），我们称为概率 S；另一个是"),s("strong",[a._v("称呼匹配")]),a._v("，我们称之为概率 A。我们举一些例子：")]),a._v(" "),s("ul",[s("li",[a._v("早上好：无论是对机器人说，还是对其他群友说，机器人响应这个问题都是正常的，因此适合 S=1，A=1。")]),a._v(" "),s("li",[a._v("我喜欢你：如果这个问题不是对机器人说的，那么机器人不应该响应它，因此适合 S=0，A=1。")]),a._v(" "),s("li",[a._v("荭茶：如果这个问题被加上了机器人前缀，这句话的意思就发生了改变，因此适合 S=1，A=0。")])]),a._v(" "),s("p",[a._v("这里对"),s("strong",[a._v("前缀")]),a._v("的严格定义是，一个问题"),s("strong",[a._v("以称呼开头，且之后还有其他字符")]),a._v("。因此昵称本身不属于含有前缀的问题。")]),a._v(" "),s("p",[a._v("当一个问题被创建或修改时，-p 会被理解成概率 S，-P 会被理解成概率 A。如果问题存在前缀，则其将被删除，且默认概率为 p=0, P=1；否则默认概率为 p=1, P=0。当机器人收到一条消息时，如果该消息含有前缀，则其将被删除。之后正常获取可能触发的问答列表。如果之前没有删除前缀，则使用这些问答的概率 S 执行上文中的概率机制；否则使用这些问答的概率 A 执行上文中的概率机制。")]),a._v(" "),s("p",[a._v("举个例子，假设问答 1 和问答 2 的问题都是“早上好”，且问答 1 的触发概率为 S=0.6，A=0.8，问答 2 的触发概率为 S=1，A=0。则输入“早上好”时，问答 1, 2 分别取概率 0.6, 1，最终经过标准化，以 0.375 的概率触发问答 1，以 0.625 的概率触发问答 2。输入“@bot，早上好”时，问答 1, 2 分别取概率 0.8, 0，最终以 0.8 的概率触发问答 1。")]),a._v(" "),s("h2",{attrs:{id:"称呼本身作为问题触发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#称呼本身作为问题触发"}},[a._v("#")]),a._v(" 称呼本身作为问题触发")]),a._v(" "),s("p",[a._v("上面已经介绍过了，昵称本身不属于含有前缀的问题，因此比较特殊。如果它本身作为问题被触发，则该会话的短时间内，即使没有前缀，获得的问题也会取 S, A 两个概率的最大值为最终概率。为什么这样设计呢？因为现实中，许多人会把话拆开说。举下面的例子：")]),a._v(" "),s("panel-view",{attrs:{title:"聊天记录"}},[s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("四季酱，我喜欢你")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("你就是桃饱网大会员？")])],1),a._v(" "),s("panel-view",{attrs:{title:"聊天记录"}},[s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("四季酱")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("有什么事吗？")]),a._v(" "),s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("我喜欢你")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("你就是桃饱网大会员？")])],1),a._v(" "),s("p",[a._v("我们可以看到，虽然单独的“我喜欢你”不能触发“你就是桃饱网大会员”的回应（S=0），但是如果“我喜欢你”紧跟在一句“四季酱”之后，显然这句话是对机器人说的。因此在 Koishi 的教学系统中，称呼问题本身能够激活当前会话的 A 概率。")]),a._v(" "),s("h2",{attrs:{id:"重定向到称呼匹配问答"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重定向到称呼匹配问答"}},[a._v("#")]),a._v(" 重定向到称呼匹配问答")]),a._v(" "),s("p",[a._v("如果要重定向到称呼匹配的问答时，请"),s("strong",[a._v("在目标问题上也加上前缀")]),a._v("，否则将无法触发下一个问题。例如，下面的例子将"),s("strong",[a._v("无法工作")]),a._v("：")]),a._v(" "),s("panel-view",{attrs:{title:"聊天记录"}},[s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("# 四季酱，自我介绍 大家好，我叫古明地恋！")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("问答已添加，编号为 1001。")]),a._v(" "),s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("# 四季酱，你能做什么 => 自我介绍")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("问答已添加，编号为 1002。")])],1),a._v(" "),s("p",[a._v("反过来，利用这种特性，我们也可以实现一些更加高级的效果。假如我们希望构造一个问答，使得其在正常情况下只能带称呼触发；但是在特定问题触发后可以不带称呼触发（参见 "),s("RouterLink",{attrs:{to:"/plugins/teach/pred-succ.html"}},[s("strong",[a._v("前置和后继机制")])]),a._v("）。在正常情况下这是做不到的，因为 Koishi 不会接受问题和回答都相同的两个教学问答。但有了重定向语法之后，只需结合重定向语法和后继机制就可以实现这种需求：")],1),a._v(" "),s("panel-view",{attrs:{title:"聊天记录"}},[s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("# 四季酱爬 你才爬（指")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("问答已添加，编号为 1011。")]),a._v(" "),s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("# 捕捉 捕捉失败，野生的四季酱跑掉了 ># 爬 => 四季酱爬")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("问答已添加，编号为 1012。"),s("br"),a._v("问答已添加，编号为 1013。")]),a._v(" "),s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("捕捉")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("捕捉失败，野生的四季酱跑掉了")]),a._v(" "),s("chat-message",{attrs:{nickname:"Alice",color:"#cc0066"}},[a._v("爬")]),a._v(" "),s("chat-message",{attrs:{nickname:"四季酱",avatar:"/koishi.png"}},[a._v("你才爬（指")])],1)],1)}),[],!1,null,null,null);t.default=e.exports}}]);